import { app, BrowserWindow, ipcMain, dialog } from "electron";
import { channels } from "./shared/constants";
import fs from "fs";
import axios from "axios";

// import { ClarifaiStub, grpc } from "clarifai-nodejs-grpc"; // error

// eslint-disable-next-line @typescript-eslint/no-var-requires
// const { ClarifaiStub, grpc } = require("clarifai-nodejs-grpc"); // For Node.js integration

// const stub = ClarifaiStub.grpc();

// // Replace with your actual Clarifai API key
// const PAT = process.env.CLARIFAI_PAT;
// const metadata = new grpc.Metadata();
// metadata.set("authorization", "Key " + PAT);
// const USER_ID = "clarifai";
// const APP_ID = "main";
// // Change these to whatever model and image URL you want to use
// const MODEL_ID = "food-item-recognition";
// const MODEL_VERSION_ID = "1d5fd481e0cf4826aa72ec3ff049e044";

// const { VERSION, WOO_HOO } = process.env;
// console.log(VERSION, WOO_HOO, "what is version and woohoo");
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
console.log(MAIN_WINDOW_WEBPACK_ENTRY, "what is main window webpack entry");
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Locales
// https://michael-hsu.medium.com/%E7%94%A8-react-%E5%92%8C-electron-%E9%96%8B%E7%99%BC%E5%A4%9A%E5%9C%8B%E8%AA%9E%E7%B3%BB%E7%9A%84%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F-i18n-eea392eeb7d8

// i18n.on('loaded', (loaded) => {
//   i18n.changeLanguage('en-US', (err, t) => {
//     if (err) {
//       console.error(err);
//     }
//   });
//   i18n.off('loaded');
// });

// i18n.on('languageChanged', (lng) => {
//   setupMenu(i18n);
// });

// i18n.on('failedLoading', (lng, ns, msg) => {
//   console.error(msg);
// });

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// Testing ipcMain

const products = {
  notebook: {
    name: "notebook",
    price: "2500",
    color: "gray",
  },
  headphone: {
    name: "headphone",
    price: "700",
    color: "black",
  },
};

ipcMain.on(channels.GET_DATA, (event, arg) => {
  const { product } = arg;
  event.sender.send(channels.GET_DATA, products[product]);
});

ipcMain.on(channels.GET_TODO_DATA, async (event, arg) => {
  try {
    const response = await axios.get(
      "https://jsonplaceholder.typicode.com/todos"
    ); // Fetch todos from the API
    event.sender.send(channels.GET_TODO_DATA_RES, response.data); // Send response back to frontend
  } catch (error) {
    console.error("Error fetching data:", error);
  }
});

// quit the app
ipcMain.handle(channels.QUIT, () => {
  app.quit();
});

// handle Login

ipcMain.on(channels.LOGIN, (event, email, password) => {
  // handle authenticaiton here
  const EMAIL = "test@gmail.com";
  const PASS = "123456";
  const isAuthenticated = email === EMAIL && PASS === password;
  const response = { success: isAuthenticated, code: 200 };

  event.sender.send(channels.LOGIN_RESPONSE, response);
});

// Option + âŒ˜ + I to open dev tools

// file select with dialog
ipcMain.on("chooseFile", async (event, arg) => {
  const result = await dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [{ name: "Images", extensions: ["png", "jpg", "jpeg"] }],
  });

  if (!result.canceled) {
    const filePath = result.filePaths[0];
    const base64 = await fs.promises.readFile(filePath, { encoding: "base64" });
    event.reply("chosenFile", base64);
  }
});

// Test clarifai

// async function recognizeImage(imageUrl: string): Promise<any[]> {
//   return new Promise((resolve, reject) => {
//     stub.PostModelOutputs(
//       {
//         user_app_id: {
//           user_id: USER_ID, // Replace with your user ID
//           app_id: APP_ID, // Replace with your app ID
//         },
//         model_id: MODEL_ID, // Replace with your Clarifai model ID
//         version_id: MODEL_VERSION_ID, // Optional: Use the latest version
//         inputs: [
//           {
//             data: {
//               image: {
//                 url: imageUrl,
//                 // base64: imageBytes, // For base64 data
//                 allow_duplicate_url: true,
//               },
//             },
//           },
//         ],
//       },
//       metadata,
//       (err, response) => {
//         if (err) {
//           reject(err);
//           return;
//         }

//         if (response.status.code !== 10000) {
//           reject(new Error("Post model outputs failed"));
//           return;
//         }

//         const regions = response.outputs[0].data.regions;
//         const concepts = [];

//         regions.forEach((region) => {
//           region.data.concepts.forEach((concept) => {
//             concepts.push({
//               name: concept.name,
//               value: concept.value.toFixed(4),
//             });
//           });
//         });

//         resolve(concepts);
//       }
//     );
//   });
// }

// ipcMain.on("chooseFile", async (event, arg) => {
//   const result = await dialog.showOpenDialog({
//     properties: ["openFile"],
//     filters: [{ name: "Images", extensions: ["png", "jpg", "jpeg"] }],
//   });

//   if (!result.canceled) {
//     const filePath = result.filePaths[0];
//     const base64 = await fs.promises.readFile(filePath, { encoding: "base64" });

//     try {
//       const concepts = await recognizeImage(base64);
//       event.reply("imageRecognized", concepts); // Send results to frontend
//     } catch (error) {
//       console.error(error);
//       event.reply("imageRecognitionError", error.message); // Send error
//     }
//   }
// });
